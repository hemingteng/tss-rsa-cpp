// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tss_rsa.proto

#ifndef PROTOBUF_INCLUDED_tss_5frsa_2eproto
#define PROTOBUF_INCLUDED_tss_5frsa_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tss_5frsa_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_tss_5frsa_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_tss_5frsa_2eproto();
namespace safeheron {
namespace proto {
class RSAKeyMeta;
class RSAKeyMetaDefaultTypeInternal;
extern RSAKeyMetaDefaultTypeInternal _RSAKeyMeta_default_instance_;
class RSAPrivateKeyShare;
class RSAPrivateKeyShareDefaultTypeInternal;
extern RSAPrivateKeyShareDefaultTypeInternal _RSAPrivateKeyShare_default_instance_;
class RSAPublicKey;
class RSAPublicKeyDefaultTypeInternal;
extern RSAPublicKeyDefaultTypeInternal _RSAPublicKey_default_instance_;
class RSASigShare;
class RSASigShareDefaultTypeInternal;
extern RSASigShareDefaultTypeInternal _RSASigShare_default_instance_;
class RSASigShareProof;
class RSASigShareProofDefaultTypeInternal;
extern RSASigShareProofDefaultTypeInternal _RSASigShareProof_default_instance_;
}  // namespace proto
}  // namespace safeheron
namespace google {
namespace protobuf {
template<> ::safeheron::proto::RSAKeyMeta* Arena::CreateMaybeMessage<::safeheron::proto::RSAKeyMeta>(Arena*);
template<> ::safeheron::proto::RSAPrivateKeyShare* Arena::CreateMaybeMessage<::safeheron::proto::RSAPrivateKeyShare>(Arena*);
template<> ::safeheron::proto::RSAPublicKey* Arena::CreateMaybeMessage<::safeheron::proto::RSAPublicKey>(Arena*);
template<> ::safeheron::proto::RSASigShare* Arena::CreateMaybeMessage<::safeheron::proto::RSASigShare>(Arena*);
template<> ::safeheron::proto::RSASigShareProof* Arena::CreateMaybeMessage<::safeheron::proto::RSASigShareProof>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace safeheron {
namespace proto {

// ===================================================================

class RSAPublicKey :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAPublicKey) */ {
 public:
  RSAPublicKey();
  virtual ~RSAPublicKey();

  RSAPublicKey(const RSAPublicKey& from);

  inline RSAPublicKey& operator=(const RSAPublicKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RSAPublicKey(RSAPublicKey&& from) noexcept
    : RSAPublicKey() {
    *this = ::std::move(from);
  }

  inline RSAPublicKey& operator=(RSAPublicKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RSAPublicKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RSAPublicKey* internal_default_instance() {
    return reinterpret_cast<const RSAPublicKey*>(
               &_RSAPublicKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(RSAPublicKey* other);
  friend void swap(RSAPublicKey& a, RSAPublicKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RSAPublicKey* New() const final {
    return CreateMaybeMessage<RSAPublicKey>(nullptr);
  }

  RSAPublicKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RSAPublicKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RSAPublicKey& from);
  void MergeFrom(const RSAPublicKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAPublicKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string n = 1;
  void clear_n();
  static const int kNFieldNumber = 1;
  const ::std::string& n() const;
  void set_n(const ::std::string& value);
  #if LANG_CXX11
  void set_n(::std::string&& value);
  #endif
  void set_n(const char* value);
  void set_n(const char* value, size_t size);
  ::std::string* mutable_n();
  ::std::string* release_n();
  void set_allocated_n(::std::string* n);

  // string e = 2;
  void clear_e();
  static const int kEFieldNumber = 2;
  const ::std::string& e() const;
  void set_e(const ::std::string& value);
  #if LANG_CXX11
  void set_e(::std::string&& value);
  #endif
  void set_e(const char* value);
  void set_e(const char* value, size_t size);
  ::std::string* mutable_e();
  ::std::string* release_e();
  void set_allocated_e(::std::string* e);

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAPublicKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr n_;
  ::google::protobuf::internal::ArenaStringPtr e_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSAPrivateKeyShare :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAPrivateKeyShare) */ {
 public:
  RSAPrivateKeyShare();
  virtual ~RSAPrivateKeyShare();

  RSAPrivateKeyShare(const RSAPrivateKeyShare& from);

  inline RSAPrivateKeyShare& operator=(const RSAPrivateKeyShare& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RSAPrivateKeyShare(RSAPrivateKeyShare&& from) noexcept
    : RSAPrivateKeyShare() {
    *this = ::std::move(from);
  }

  inline RSAPrivateKeyShare& operator=(RSAPrivateKeyShare&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RSAPrivateKeyShare& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RSAPrivateKeyShare* internal_default_instance() {
    return reinterpret_cast<const RSAPrivateKeyShare*>(
               &_RSAPrivateKeyShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RSAPrivateKeyShare* other);
  friend void swap(RSAPrivateKeyShare& a, RSAPrivateKeyShare& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RSAPrivateKeyShare* New() const final {
    return CreateMaybeMessage<RSAPrivateKeyShare>(nullptr);
  }

  RSAPrivateKeyShare* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RSAPrivateKeyShare>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RSAPrivateKeyShare& from);
  void MergeFrom(const RSAPrivateKeyShare& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAPrivateKeyShare* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string si = 2;
  void clear_si();
  static const int kSiFieldNumber = 2;
  const ::std::string& si() const;
  void set_si(const ::std::string& value);
  #if LANG_CXX11
  void set_si(::std::string&& value);
  #endif
  void set_si(const char* value);
  void set_si(const char* value, size_t size);
  ::std::string* mutable_si();
  ::std::string* release_si();
  void set_allocated_si(::std::string* si);

  // int32 i = 1;
  void clear_i();
  static const int kIFieldNumber = 1;
  ::google::protobuf::int32 i() const;
  void set_i(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAPrivateKeyShare)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr si_;
  ::google::protobuf::int32 i_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSAKeyMeta :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSAKeyMeta) */ {
 public:
  RSAKeyMeta();
  virtual ~RSAKeyMeta();

  RSAKeyMeta(const RSAKeyMeta& from);

  inline RSAKeyMeta& operator=(const RSAKeyMeta& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RSAKeyMeta(RSAKeyMeta&& from) noexcept
    : RSAKeyMeta() {
    *this = ::std::move(from);
  }

  inline RSAKeyMeta& operator=(RSAKeyMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RSAKeyMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RSAKeyMeta* internal_default_instance() {
    return reinterpret_cast<const RSAKeyMeta*>(
               &_RSAKeyMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RSAKeyMeta* other);
  friend void swap(RSAKeyMeta& a, RSAKeyMeta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RSAKeyMeta* New() const final {
    return CreateMaybeMessage<RSAKeyMeta>(nullptr);
  }

  RSAKeyMeta* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RSAKeyMeta>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RSAKeyMeta& from);
  void MergeFrom(const RSAKeyMeta& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSAKeyMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string vki_arr = 5;
  int vki_arr_size() const;
  void clear_vki_arr();
  static const int kVkiArrFieldNumber = 5;
  const ::std::string& vki_arr(int index) const;
  ::std::string* mutable_vki_arr(int index);
  void set_vki_arr(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_vki_arr(int index, ::std::string&& value);
  #endif
  void set_vki_arr(int index, const char* value);
  void set_vki_arr(int index, const char* value, size_t size);
  ::std::string* add_vki_arr();
  void add_vki_arr(const ::std::string& value);
  #if LANG_CXX11
  void add_vki_arr(::std::string&& value);
  #endif
  void add_vki_arr(const char* value);
  void add_vki_arr(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& vki_arr() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_vki_arr();

  // string vkv = 3;
  void clear_vkv();
  static const int kVkvFieldNumber = 3;
  const ::std::string& vkv() const;
  void set_vkv(const ::std::string& value);
  #if LANG_CXX11
  void set_vkv(::std::string&& value);
  #endif
  void set_vkv(const char* value);
  void set_vkv(const char* value, size_t size);
  ::std::string* mutable_vkv();
  ::std::string* release_vkv();
  void set_allocated_vkv(::std::string* vkv);

  // string vku = 4;
  void clear_vku();
  static const int kVkuFieldNumber = 4;
  const ::std::string& vku() const;
  void set_vku(const ::std::string& value);
  #if LANG_CXX11
  void set_vku(::std::string&& value);
  #endif
  void set_vku(const char* value);
  void set_vku(const char* value, size_t size);
  ::std::string* mutable_vku();
  ::std::string* release_vku();
  void set_allocated_vku(::std::string* vku);

  // int32 k = 1;
  void clear_k();
  static const int kKFieldNumber = 1;
  ::google::protobuf::int32 k() const;
  void set_k(::google::protobuf::int32 value);

  // int32 l = 2;
  void clear_l();
  static const int kLFieldNumber = 2;
  ::google::protobuf::int32 l() const;
  void set_l(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSAKeyMeta)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> vki_arr_;
  ::google::protobuf::internal::ArenaStringPtr vkv_;
  ::google::protobuf::internal::ArenaStringPtr vku_;
  ::google::protobuf::int32 k_;
  ::google::protobuf::int32 l_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSASigShare :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSASigShare) */ {
 public:
  RSASigShare();
  virtual ~RSASigShare();

  RSASigShare(const RSASigShare& from);

  inline RSASigShare& operator=(const RSASigShare& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RSASigShare(RSASigShare&& from) noexcept
    : RSASigShare() {
    *this = ::std::move(from);
  }

  inline RSASigShare& operator=(RSASigShare&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RSASigShare& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RSASigShare* internal_default_instance() {
    return reinterpret_cast<const RSASigShare*>(
               &_RSASigShare_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RSASigShare* other);
  friend void swap(RSASigShare& a, RSASigShare& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RSASigShare* New() const final {
    return CreateMaybeMessage<RSASigShare>(nullptr);
  }

  RSASigShare* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RSASigShare>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RSASigShare& from);
  void MergeFrom(const RSASigShare& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSASigShare* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sig_share = 2;
  void clear_sig_share();
  static const int kSigShareFieldNumber = 2;
  const ::std::string& sig_share() const;
  void set_sig_share(const ::std::string& value);
  #if LANG_CXX11
  void set_sig_share(::std::string&& value);
  #endif
  void set_sig_share(const char* value);
  void set_sig_share(const char* value, size_t size);
  ::std::string* mutable_sig_share();
  ::std::string* release_sig_share();
  void set_allocated_sig_share(::std::string* sig_share);

  // string z = 3;
  void clear_z();
  static const int kZFieldNumber = 3;
  const ::std::string& z() const;
  void set_z(const ::std::string& value);
  #if LANG_CXX11
  void set_z(::std::string&& value);
  #endif
  void set_z(const char* value);
  void set_z(const char* value, size_t size);
  ::std::string* mutable_z();
  ::std::string* release_z();
  void set_allocated_z(::std::string* z);

  // string c = 4;
  void clear_c();
  static const int kCFieldNumber = 4;
  const ::std::string& c() const;
  void set_c(const ::std::string& value);
  #if LANG_CXX11
  void set_c(::std::string&& value);
  #endif
  void set_c(const char* value);
  void set_c(const char* value, size_t size);
  ::std::string* mutable_c();
  ::std::string* release_c();
  void set_allocated_c(::std::string* c);

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSASigShare)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sig_share_;
  ::google::protobuf::internal::ArenaStringPtr z_;
  ::google::protobuf::internal::ArenaStringPtr c_;
  ::google::protobuf::int32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// -------------------------------------------------------------------

class RSASigShareProof :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.RSASigShareProof) */ {
 public:
  RSASigShareProof();
  virtual ~RSASigShareProof();

  RSASigShareProof(const RSASigShareProof& from);

  inline RSASigShareProof& operator=(const RSASigShareProof& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RSASigShareProof(RSASigShareProof&& from) noexcept
    : RSASigShareProof() {
    *this = ::std::move(from);
  }

  inline RSASigShareProof& operator=(RSASigShareProof&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RSASigShareProof& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RSASigShareProof* internal_default_instance() {
    return reinterpret_cast<const RSASigShareProof*>(
               &_RSASigShareProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RSASigShareProof* other);
  friend void swap(RSASigShareProof& a, RSASigShareProof& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RSASigShareProof* New() const final {
    return CreateMaybeMessage<RSASigShareProof>(nullptr);
  }

  RSASigShareProof* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RSASigShareProof>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RSASigShareProof& from);
  void MergeFrom(const RSASigShareProof& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RSASigShareProof* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string z = 1;
  void clear_z();
  static const int kZFieldNumber = 1;
  const ::std::string& z() const;
  void set_z(const ::std::string& value);
  #if LANG_CXX11
  void set_z(::std::string&& value);
  #endif
  void set_z(const char* value);
  void set_z(const char* value, size_t size);
  ::std::string* mutable_z();
  ::std::string* release_z();
  void set_allocated_z(::std::string* z);

  // string c = 2;
  void clear_c();
  static const int kCFieldNumber = 2;
  const ::std::string& c() const;
  void set_c(const ::std::string& value);
  #if LANG_CXX11
  void set_c(::std::string&& value);
  #endif
  void set_c(const char* value);
  void set_c(const char* value, size_t size);
  ::std::string* mutable_c();
  ::std::string* release_c();
  void set_allocated_c(::std::string* c);

  // @@protoc_insertion_point(class_scope:safeheron.proto.RSASigShareProof)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr z_;
  ::google::protobuf::internal::ArenaStringPtr c_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_tss_5frsa_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RSAPublicKey

// string n = 1;
inline void RSAPublicKey::clear_n() {
  n_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSAPublicKey::n() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPublicKey.n)
  return n_.GetNoArena();
}
inline void RSAPublicKey::set_n(const ::std::string& value) {
  
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPublicKey.n)
}
#if LANG_CXX11
inline void RSAPublicKey::set_n(::std::string&& value) {
  
  n_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAPublicKey.n)
}
#endif
inline void RSAPublicKey::set_n(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAPublicKey.n)
}
inline void RSAPublicKey::set_n(const char* value, size_t size) {
  
  n_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAPublicKey.n)
}
inline ::std::string* RSAPublicKey::mutable_n() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPublicKey.n)
  return n_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSAPublicKey::release_n() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPublicKey.n)
  
  return n_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSAPublicKey::set_allocated_n(::std::string* n) {
  if (n != nullptr) {
    
  } else {
    
  }
  n_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), n);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPublicKey.n)
}

// string e = 2;
inline void RSAPublicKey::clear_e() {
  e_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSAPublicKey::e() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPublicKey.e)
  return e_.GetNoArena();
}
inline void RSAPublicKey::set_e(const ::std::string& value) {
  
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPublicKey.e)
}
#if LANG_CXX11
inline void RSAPublicKey::set_e(::std::string&& value) {
  
  e_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAPublicKey.e)
}
#endif
inline void RSAPublicKey::set_e(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAPublicKey.e)
}
inline void RSAPublicKey::set_e(const char* value, size_t size) {
  
  e_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAPublicKey.e)
}
inline ::std::string* RSAPublicKey::mutable_e() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPublicKey.e)
  return e_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSAPublicKey::release_e() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPublicKey.e)
  
  return e_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSAPublicKey::set_allocated_e(::std::string* e) {
  if (e != nullptr) {
    
  } else {
    
  }
  e_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), e);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPublicKey.e)
}

// -------------------------------------------------------------------

// RSAPrivateKeyShare

// int32 i = 1;
inline void RSAPrivateKeyShare::clear_i() {
  i_ = 0;
}
inline ::google::protobuf::int32 RSAPrivateKeyShare::i() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPrivateKeyShare.i)
  return i_;
}
inline void RSAPrivateKeyShare::set_i(::google::protobuf::int32 value) {
  
  i_ = value;
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPrivateKeyShare.i)
}

// string si = 2;
inline void RSAPrivateKeyShare::clear_si() {
  si_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSAPrivateKeyShare::si() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAPrivateKeyShare.si)
  return si_.GetNoArena();
}
inline void RSAPrivateKeyShare::set_si(const ::std::string& value) {
  
  si_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAPrivateKeyShare.si)
}
#if LANG_CXX11
inline void RSAPrivateKeyShare::set_si(::std::string&& value) {
  
  si_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAPrivateKeyShare.si)
}
#endif
inline void RSAPrivateKeyShare::set_si(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  si_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAPrivateKeyShare.si)
}
inline void RSAPrivateKeyShare::set_si(const char* value, size_t size) {
  
  si_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAPrivateKeyShare.si)
}
inline ::std::string* RSAPrivateKeyShare::mutable_si() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAPrivateKeyShare.si)
  return si_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSAPrivateKeyShare::release_si() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAPrivateKeyShare.si)
  
  return si_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSAPrivateKeyShare::set_allocated_si(::std::string* si) {
  if (si != nullptr) {
    
  } else {
    
  }
  si_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), si);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAPrivateKeyShare.si)
}

// -------------------------------------------------------------------

// RSAKeyMeta

// int32 k = 1;
inline void RSAKeyMeta::clear_k() {
  k_ = 0;
}
inline ::google::protobuf::int32 RSAKeyMeta::k() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.k)
  return k_;
}
inline void RSAKeyMeta::set_k(::google::protobuf::int32 value) {
  
  k_ = value;
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.k)
}

// int32 l = 2;
inline void RSAKeyMeta::clear_l() {
  l_ = 0;
}
inline ::google::protobuf::int32 RSAKeyMeta::l() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.l)
  return l_;
}
inline void RSAKeyMeta::set_l(::google::protobuf::int32 value) {
  
  l_ = value;
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.l)
}

// string vkv = 3;
inline void RSAKeyMeta::clear_vkv() {
  vkv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSAKeyMeta::vkv() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vkv)
  return vkv_.GetNoArena();
}
inline void RSAKeyMeta::set_vkv(const ::std::string& value) {
  
  vkv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vkv)
}
#if LANG_CXX11
inline void RSAKeyMeta::set_vkv(::std::string&& value) {
  
  vkv_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAKeyMeta.vkv)
}
#endif
inline void RSAKeyMeta::set_vkv(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vkv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAKeyMeta.vkv)
}
inline void RSAKeyMeta::set_vkv(const char* value, size_t size) {
  
  vkv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAKeyMeta.vkv)
}
inline ::std::string* RSAKeyMeta::mutable_vkv() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vkv)
  return vkv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSAKeyMeta::release_vkv() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAKeyMeta.vkv)
  
  return vkv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSAKeyMeta::set_allocated_vkv(::std::string* vkv) {
  if (vkv != nullptr) {
    
  } else {
    
  }
  vkv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vkv);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAKeyMeta.vkv)
}

// string vku = 4;
inline void RSAKeyMeta::clear_vku() {
  vku_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSAKeyMeta::vku() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vku)
  return vku_.GetNoArena();
}
inline void RSAKeyMeta::set_vku(const ::std::string& value) {
  
  vku_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vku)
}
#if LANG_CXX11
inline void RSAKeyMeta::set_vku(::std::string&& value) {
  
  vku_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSAKeyMeta.vku)
}
#endif
inline void RSAKeyMeta::set_vku(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vku_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAKeyMeta.vku)
}
inline void RSAKeyMeta::set_vku(const char* value, size_t size) {
  
  vku_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAKeyMeta.vku)
}
inline ::std::string* RSAKeyMeta::mutable_vku() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vku)
  return vku_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSAKeyMeta::release_vku() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSAKeyMeta.vku)
  
  return vku_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSAKeyMeta::set_allocated_vku(::std::string* vku) {
  if (vku != nullptr) {
    
  } else {
    
  }
  vku_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vku);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSAKeyMeta.vku)
}

// repeated string vki_arr = 5;
inline int RSAKeyMeta::vki_arr_size() const {
  return vki_arr_.size();
}
inline void RSAKeyMeta::clear_vki_arr() {
  vki_arr_.Clear();
}
inline const ::std::string& RSAKeyMeta::vki_arr(int index) const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_.Get(index);
}
inline ::std::string* RSAKeyMeta::mutable_vki_arr(int index) {
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_.Mutable(index);
}
inline void RSAKeyMeta::set_vki_arr(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vki_arr)
  vki_arr_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RSAKeyMeta::set_vki_arr(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:safeheron.proto.RSAKeyMeta.vki_arr)
  vki_arr_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RSAKeyMeta::set_vki_arr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vki_arr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::set_vki_arr(int index, const char* value, size_t size) {
  vki_arr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline ::std::string* RSAKeyMeta::add_vki_arr() {
  // @@protoc_insertion_point(field_add_mutable:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_.Add();
}
inline void RSAKeyMeta::add_vki_arr(const ::std::string& value) {
  vki_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:safeheron.proto.RSAKeyMeta.vki_arr)
}
#if LANG_CXX11
inline void RSAKeyMeta::add_vki_arr(::std::string&& value) {
  vki_arr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:safeheron.proto.RSAKeyMeta.vki_arr)
}
#endif
inline void RSAKeyMeta::add_vki_arr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  vki_arr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline void RSAKeyMeta::add_vki_arr(const char* value, size_t size) {
  vki_arr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:safeheron.proto.RSAKeyMeta.vki_arr)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
RSAKeyMeta::vki_arr() const {
  // @@protoc_insertion_point(field_list:safeheron.proto.RSAKeyMeta.vki_arr)
  return vki_arr_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
RSAKeyMeta::mutable_vki_arr() {
  // @@protoc_insertion_point(field_mutable_list:safeheron.proto.RSAKeyMeta.vki_arr)
  return &vki_arr_;
}

// -------------------------------------------------------------------

// RSASigShare

// int32 index = 1;
inline void RSASigShare::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 RSASigShare::index() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.index)
  return index_;
}
inline void RSASigShare::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.index)
}

// string sig_share = 2;
inline void RSASigShare::clear_sig_share() {
  sig_share_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSASigShare::sig_share() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.sig_share)
  return sig_share_.GetNoArena();
}
inline void RSASigShare::set_sig_share(const ::std::string& value) {
  
  sig_share_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.sig_share)
}
#if LANG_CXX11
inline void RSASigShare::set_sig_share(::std::string&& value) {
  
  sig_share_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShare.sig_share)
}
#endif
inline void RSASigShare::set_sig_share(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sig_share_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShare.sig_share)
}
inline void RSASigShare::set_sig_share(const char* value, size_t size) {
  
  sig_share_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShare.sig_share)
}
inline ::std::string* RSASigShare::mutable_sig_share() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.sig_share)
  return sig_share_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSASigShare::release_sig_share() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.sig_share)
  
  return sig_share_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSASigShare::set_allocated_sig_share(::std::string* sig_share) {
  if (sig_share != nullptr) {
    
  } else {
    
  }
  sig_share_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sig_share);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.sig_share)
}

// string z = 3;
inline void RSASigShare::clear_z() {
  z_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSASigShare::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.z)
  return z_.GetNoArena();
}
inline void RSASigShare::set_z(const ::std::string& value) {
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.z)
}
#if LANG_CXX11
inline void RSASigShare::set_z(::std::string&& value) {
  
  z_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShare.z)
}
#endif
inline void RSASigShare::set_z(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShare.z)
}
inline void RSASigShare::set_z(const char* value, size_t size) {
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShare.z)
}
inline ::std::string* RSASigShare::mutable_z() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.z)
  return z_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSASigShare::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.z)
  
  return z_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSASigShare::set_allocated_z(::std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), z);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.z)
}

// string c = 4;
inline void RSASigShare::clear_c() {
  c_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSASigShare::c() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShare.c)
  return c_.GetNoArena();
}
inline void RSASigShare::set_c(const ::std::string& value) {
  
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShare.c)
}
#if LANG_CXX11
inline void RSASigShare::set_c(::std::string&& value) {
  
  c_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShare.c)
}
#endif
inline void RSASigShare::set_c(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShare.c)
}
inline void RSASigShare::set_c(const char* value, size_t size) {
  
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShare.c)
}
inline ::std::string* RSASigShare::mutable_c() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShare.c)
  return c_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSASigShare::release_c() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShare.c)
  
  return c_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSASigShare::set_allocated_c(::std::string* c) {
  if (c != nullptr) {
    
  } else {
    
  }
  c_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), c);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShare.c)
}

// -------------------------------------------------------------------

// RSASigShareProof

// string z = 1;
inline void RSASigShareProof::clear_z() {
  z_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSASigShareProof::z() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShareProof.z)
  return z_.GetNoArena();
}
inline void RSASigShareProof::set_z(const ::std::string& value) {
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShareProof.z)
}
#if LANG_CXX11
inline void RSASigShareProof::set_z(::std::string&& value) {
  
  z_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShareProof.z)
}
#endif
inline void RSASigShareProof::set_z(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShareProof.z)
}
inline void RSASigShareProof::set_z(const char* value, size_t size) {
  
  z_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShareProof.z)
}
inline ::std::string* RSASigShareProof::mutable_z() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShareProof.z)
  return z_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSASigShareProof::release_z() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShareProof.z)
  
  return z_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSASigShareProof::set_allocated_z(::std::string* z) {
  if (z != nullptr) {
    
  } else {
    
  }
  z_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), z);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShareProof.z)
}

// string c = 2;
inline void RSASigShareProof::clear_c() {
  c_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RSASigShareProof::c() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.RSASigShareProof.c)
  return c_.GetNoArena();
}
inline void RSASigShareProof::set_c(const ::std::string& value) {
  
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:safeheron.proto.RSASigShareProof.c)
}
#if LANG_CXX11
inline void RSASigShareProof::set_c(::std::string&& value) {
  
  c_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:safeheron.proto.RSASigShareProof.c)
}
#endif
inline void RSASigShareProof::set_c(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:safeheron.proto.RSASigShareProof.c)
}
inline void RSASigShareProof::set_c(const char* value, size_t size) {
  
  c_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:safeheron.proto.RSASigShareProof.c)
}
inline ::std::string* RSASigShareProof::mutable_c() {
  
  // @@protoc_insertion_point(field_mutable:safeheron.proto.RSASigShareProof.c)
  return c_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RSASigShareProof::release_c() {
  // @@protoc_insertion_point(field_release:safeheron.proto.RSASigShareProof.c)
  
  return c_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RSASigShareProof::set_allocated_c(::std::string* c) {
  if (c != nullptr) {
    
  } else {
    
  }
  c_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), c);
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.RSASigShareProof.c)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace safeheron

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_tss_5frsa_2eproto
